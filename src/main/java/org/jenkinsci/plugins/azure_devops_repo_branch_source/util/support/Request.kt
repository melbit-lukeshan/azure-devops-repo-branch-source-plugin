package org.jenkinsci.plugins.azure_devops_repo_branch_source.util.support

import java.util.*
import kotlin.collections.HashMap

/**
 * T is the [Result.Good] value type
 * R is the [Result.HttpError] value type. If you don't care about this result type, pass [Any]
 * _category and _id are used to retrieve or cancel request
 */
abstract class Request<T, R>(_category: String? = null, _id: String? = null) {

    private companion object {
        val REGEX_PLACEHOLDER = Regex("""\{([\w.]+)\}""")
        val REGEX_NAME_VALUE_PAIR = Regex("""(\w+)=([^&!\{$!\}]+)""")
        val REGEX_NAME_VALUE_PLACEHOLDER_PAIR = Regex("""(\w+)=\{([\w.]+)\}""")
    }

    private var goodValue: T? = null
    private var httpErrorValue: R? = null
    val tag = Tag(_category ?: (this::class).qualifiedName.toString(), _id
            ?: UUID.randomUUID().toString())

    /**
     *  Mandatory JSON processor to use
     */
    abstract val jsonProcessor: JsonProcessor
    /**
     *  Mandatory HTTP method to use
     */
    abstract val method: Method
    /**
     *  Mandatory host format like "https://api.github.com:{portNumber}"
     *  Can optionally has dynamic content between curly braces
     *  The content between curly braces should be the name of a property in the request
     */
    protected abstract val host: String
    /**
     *  Optional endpoint format like "/repos/{versionNumber}"
     *  Can optionally has dynamic content between curly braces
     *  The content between curly braces should be the name of a property in the request
     */
    protected open val endpoint: String? = null
    /**
     *  Optional path format like "/{repoUser}/{repoName}"
     *  Can optionally has dynamic content between curly braces
     *  The content between curly braces should be the name of a property in the request
     */
    protected open val path: String? = null
    /**
     * Optional body for [Method.PATCH] [Method.POST] [Method.PUT] request format like """{"extraBodyWrapper":{myBody}}"""
     * Can optionally has dynamic content between curly braces
     * The content between curly braces should be the name of a property in the request
     * The dynamic content value is generated by [JsonProcessor].instanceToJson() method and will NOT be URL encoded
     * If both [body] and [parameters] exist for [Method.PATCH] [Method.POST] [Method.PUT] request, the [body] will be used, the [parameters] will be ignored
     */
    protected open val body: String? = null
    /**
     * Optional request headers
     * Format like "user=luke@gmail.com&password={secret}"
     * Can optionally has dynamic content between curly braces
     * The content between curly braces should be the name of a property in the request
     * The dynamic content value is generated by toString() method and will NOT be URL encoded
     */
    protected open val headers: String? = null
    /**
     * Optional parameters for request
     * Format like "sleep_seconds=3&delay_seconds={delay}"
     * Can optionally has dynamic content between curly braces
     * The content between curly braces should be the name of a property in the request
     * The dynamic content value is generated by toString() method and will be URL encoded
     * For [Method.DELETE] [Method.GET] [Method.HEAD] request, the parameters will be composed as queries string appending to the url
     * For [Method.PATCH] [Method.POST] [Method.PUT] request, the parameters will be composed as Form body
     */
    protected open val parameters: String? = null
    /**
     * should always be false for POST request
     */
    open val retryIfConnectionFail: Boolean = false
    /**
     * Timeout default to 10 seconds
     */
    open val timeout: Int = 10
    /**
     * Optional [Result.Good] response wrapper string in format like """{"data":*,"success":true,"errors":[]}"""
     * The "*" will be replaced with real response body string
     */
    open val goodResponseBodyWrapper: String? = null
    /**
     * Optional [Result.HttpError] response wrapper string in format like """{"data":null,"success":false,"errors":*}"
     * The "*" will be replaced with real response body string
     */
    open val httpErrorResponseBodyWrapper: String? = null

    val fullUrl: String by lazy {
        if (method == Method.PATCH || method == Method.POST || method == Method.PUT) {
            "${host.resolvePlaceholders()}${endpoint.resolvePlaceholders()
                    ?: ""}${path.resolvePlaceholders() ?: ""}"
        } else {
            "${host.resolvePlaceholders()}${endpoint.resolvePlaceholders()
                    ?: ""}${path.resolvePlaceholders()
                    ?: ""}${parameters?.let { "?$it" }.resolvePlaceholders() ?: ""}"
        }
    }

    val bodyAsJson: String? by lazy {
        body.resolvePlaceholdersByJsonProcessor()
    }

    val parametersAsMap: Map<String, String>? by lazy {
        parameters.resolveNameValuePairsAsMap()
    }

    val headersAsPairList: List<Pair<String, String>>? by lazy {
        headers.resolveNameValuePairsAsPairList()
    }

    private fun String?.resolvePlaceholders(): String? = this?.replace(REGEX_PLACEHOLDER) {
        it.groupValues[1].getPropertyValue(this@Request).toString().urlEncoded().orEmpty()
    }

    private fun String?.resolvePlaceholdersByJsonProcessor(): String? = this?.replace(REGEX_PLACEHOLDER) {
        it.groupValues[1].getPropertyValue(this@Request).let { theValue ->
            jsonProcessor.instanceToJson(theValue) ?: "null"
        }
    }

    private fun String?.resolveNameValuePairsAsMap(): Map<String, String>? {
        return this?.let { theString ->
            HashMap<String, String>().apply {
                REGEX_NAME_VALUE_PAIR.findAll(theString).forEach {
                    put(it.groupValues[1], it.groupValues[2].urlEncoded().orEmpty())
                }
                REGEX_NAME_VALUE_PLACEHOLDER_PAIR.findAll(theString).forEach {
                    put(it.groupValues[1], it.groupValues[2].getPropertyValue(this@Request).toString().urlEncoded().orEmpty())
                }
            }
        }
    }

    private fun String?.resolveNameValuePairsAsPairList(): List<Pair<String, String>>? {
        return this?.let { theString ->
            mutableListOf<Pair<String, String>>().apply {
                REGEX_NAME_VALUE_PAIR.findAll(theString).forEach {
                    add(it.groupValues[1] to it.groupValues[2])
                }
                REGEX_NAME_VALUE_PLACEHOLDER_PAIR.findAll(theString).forEach {
                    add(it.groupValues[1] to it.groupValues[2].getPropertyValue(this@Request).toString())
                }
            }
        }
    }

    enum class Method {
        DELETE, GET, HEAD, PATCH, POST, PUT
    }

    data class Tag(val category: String, val id: String)
}